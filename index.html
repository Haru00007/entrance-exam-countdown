<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>タイマー</title>
    <style>
        @font-face {
            font-family: 'DSEG7 Classic';
            src: url('./fonts/DSEG7Classic-Bold.woff2') format('woff2');
            font-weight: bold;
            font-style: normal;
        }

        @font-face {
            font-family: 'DSEG14 Classic';
            src: url('./fonts/DSEG14Classic-Bold.woff2') format('woff2');
            font-weight: bold;
            font-style: normal;
        }

        @font-face {
            font-family: 'LED Calculator';
            src: url('./fonts/LEDCalculator.ttf') format('truetype');
        }

        @font-face {
            font-family: 'Ktai-Dot-Font-LCD';
            src: url('./fonts/Ketai-dot-font-LCD.otf') format('opentype');
        }

        body {
            background-color: #000;
            font-family: 'DSEG7 Classic', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            text-align: center;
        }

        .container {
            transform: scale(1.5);
        }

        .countdown,
        .current-time {
            margin-bottom: 40px;
        }

        .dseg14 {
            font-family: 'DSEG14 Classic', sans-serif;
        }

        .countdown span,
        .current-time span {
            letter-spacing: 4px;
        }

        .space {
            margin: 0 10px;
        }

        [data-placeholder] {
            position: relative;
        }

        [data-placeholder]::before {
            content: attr(data-placeholder);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            color: rgba(255, 255, 255, 0.05);
        }

        #countdown-ms {
            font-size: 40px;
            color: white;
        }

        #day,
        #msec {
            color: orange;
        }

        #hour {
            font-size: 32px;
            color: red;
            position: relative;
            top: -2px;
        }

        #countdown-dh {
            font-size: 2em;
        }

        #current-date,
        #current-hms {
            font-size: 2em;
            color: white;
        }

        .jihou-highlight {
            color: red !important;
            transition: color 0.05s;
        }

        #day {
            display: inline-block;
            width: 115px;
            text-align: right;
        }

        #countdown-dh-labels {
            font-family: 'LED Calculator', sans-serif;
            font-size: 14px;
            color: orange;
            letter-spacing: 1px;
            margin-top: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #day-label {
            width: 120px;
            text-align: right;
        }

        #hour-label {
            width: 90px;
            text-align: right;
        }

        #msec-label {
            width: 120px;
        }

        #message-area {
            font-family: 'Ktai-Dot-Font-LCD', sans-serif;
            font-size: 24px;
            color: #0d0;
            letter-spacing: 2px;
            margin-bottom: 30px;
            height: 32px;
            line-height: 32px;
            position: relative;
        }

        #message-area::after {
            content: '_';
            position: absolute;
            animation: blink 1s step-end infinite;
            font-family: 'LED Calculator', sans-serif;
        }

        #message-area.subject-mode {
            font-family: 'LED Calculator', sans-serif;
            font-size: 32px;
            letter-spacing: 1px;
        }

        #message-area.subject-mode::after {
            content: '';
            animation: none;
        }

        @keyframes blink {
            50% {
                opacity: 0;
            }
        }

        .timer-mode-container {
            display: none;
        }

        #switch-button-area {
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        .switch-btn {
            background: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 5px 10px;
            font-family: sans-serif;
            font-size: 12px;
            cursor: pointer;
        }

        .switch-btn:active {
            background: #555;
        }

        #study-timer-display {
            font-size: 40px;
            color: white;
            height: 40px;
        }

        #study-timer-info {
            font-size: 2em;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #study-repeats-total,
        #study-program-number {
            color: orange;
        }

        #study-repeats-total {
            display: inline-block;
            width: 115px;
            text-align: right;
        }

        #study-program-number {
            display: inline-block;
            width: 115px;
            text-align: left;
        }

        #study-repeats-completed {
            color: red;
            font-size: 32px;
            position: relative;
            top: 8px;
            display: inline-block;
            width: 80px;
            text-align: center;
        }

        #study-timer-controls {
            margin-top: 10px;
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            grid-gap: 5px;
        }

        #btn-pset {
            grid-column: 2 / span 2;
        }

        #btn-start-pause {
            grid-column: 4 / span 2;
        }

        .control-btn {
            background-color: transparent;
            border: none;
            color: orange;
            font-family: 'LED Calculator', sans-serif;
            font-size: 14px;
            padding: 8px 4px;
            cursor: pointer;
            opacity: 0.8;
        }

        .control-btn:hover {
            opacity: 1.0;
        }

        .control-btn:active {
            opacity: 0.6;
        }

        .control-btn.toggled {
            color: red;
            opacity: 1.0;
        }

        #records-container {
            font-family: 'LED Calculator', sans-serif;
            color: orange;
            font-size: 16px;
            text-align: left;
            width: 500px;
            /* ▼▼▼▼▼ 以下2行を追加 ▼▼▼▼▼ */
            max-height: 55vh;
            /* コンテナの最大の高さを画面の高さの約半分に制限 */
            overflow-y: auto;
            /* 内容がはみ出た時だけ縦スクロールバーを表示 */
        }

        #log-list {
            margin-bottom: 10px;
        }

        #log-list .log-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .del-btn {
            background: none;
            border: none;
            color: red;
            font-family: 'LED Calculator', sans-serif;
            font-size: 16px;
            cursor: pointer;
            opacity: 0.7;
        }

        .del-btn:hover {
            opacity: 1.0;
        }

        #subject-summary {
            font-family: 'LED Calculator', sans-serif;
            white-space: pre;
            font-size: 16px;
            margin: 0;
        }

        #records-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            width: 100%;
            margin-bottom: 10px;
        }

        #records-title {
            font-size: 20px;
            margin-top: 10px;
            cursor: pointer;
            user-select: none;
        }

        #records-title:hover {
            color: orange;
        }

        #graph-wrapper {
            display: flex;
            flex-direction: column;
        }

        #weekly-graph {
            font-family: 'LED Calculator', sans-serif;
            white-space: pre;
            font-size: 12px;
            margin: 0;
            text-align: left;
            margin-bottom: -5px;
            line-height: 1.0;
            color: #0d0;
        }

        #graph-x-axis {
            font-family: 'LED Calculator', sans-serif;
            font-size: 12px;
            white-space: pre;
            color: #0d0;
            line-height: 1.1;
        }

        .day-label {
            display: inline-block;
            cursor: pointer;
            padding: 2px 0;
            border-radius: 2px;
            width: 7ch;
            text-align: center;
        }

        .day-label:hover {
            background-color: rgba(0, 255, 0, 0.1);
        }

        .day-label.active {
            color: orange;
            background-color: rgba(255, 165, 0, 0.1);
        }

        #graph-nav {
            font-family: 'LED Calculator', sans-serif;
            font-size: 12px;
            color: #0d0;
            text-align: center;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            white-space: pre;
        }

        .nav-arrow,
        #week-range-display {
            cursor: pointer;
            padding: 0 10px;
            /* ▼▼▼▼▼ 以下3行を追加 ▼▼▼▼▼ */
            -webkit-user-select: none;
            /* Safari, Chrome */
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            /* タップ時のハイライトを消す */
        }

        .nav-arrow:hover,
        #week-range-display:hover {
            color: orange;
        }

        /* スクロールバーの見た目調整 (任意) */
        #records-container::-webkit-scrollbar {
            width: 8px;
        }

        #records-container::-webkit-scrollbar-track {
            background: #222;
        }

        #records-container::-webkit-scrollbar-thumb {
            background-color: #555;
            border-radius: 4px;
        }

        #records-container::-webkit-scrollbar-thumb:hover {
            background-color: orange;
        }

        #comparison-summary {
            font-family: 'LED Calculator', sans-serif;
            white-space: pre;
            font-size: 16px;
            margin: 0;
            /* 色はJavaScriptで動的に設定します */
        }
    </style>
</head>

<body>
    <div class="container">
        <div id="message-area"></div>
        <div id="switch-button-area">
            <button id="switch-timer-btn" class="switch-btn">時間割タイマーへ</button>
            <button id="switch-records-btn" class="switch-btn">記録を見る</button>
        </div>
        <div id="countdown-container" class="timer-mode-container">
            <div class="countdown">
                <div id="countdown-ms"><span id="min" data-placeholder="88">00</span>:<span id="sec"
                        data-placeholder="88">00</span></div>
                <div id="countdown-dh"><span id="day" data-placeholder="888">0</span><span class="space"></span><span
                        id="hour" data-placeholder="88">00</span><span class="space"></span><span id="msec"
                        data-placeholder="888">000</span></div>
                <div id="countdown-dh-labels"><span id="day-label" class="label-unit">Days</span><span
                        class="space"></span><span id="hour-label" class="label-unit">Hours</span><span
                        class="space"></span><span id="msec-label" class="label-unit">ms</span></div>
            </div>
            <div class="current-time">
                <div id="current-date"><span id="year" data-placeholder="8888">2025</span>-<span id="month"
                        data-placeholder="88">09</span>-<span id="date" data-placeholder="88">22</span><span
                        class="dseg14" id="day-of-week" data-placeholder="~~~">MON</span></div>
                <div id="current-hms"><span id="current-hour" data-placeholder="88">21</span>:<span id="current-min"
                        data-placeholder="88">25</span>:<span id="current-sec" data-placeholder="88">15</span>.<span
                        id="current-msec" data-placeholder="8">0</span></div>
            </div>
        </div>
        <div id="study-timer-container" class="timer-mode-container">
            <div id="study-timer-display" data-placeholder="88:88"></div>
            <div id="study-timer-info">
                <span id="study-repeats-total" data-placeholder="888"></span>
                <span class="space"></span>
                <span id="study-repeats-completed" data-placeholder="88"></span>
                <span class="space"></span>
                <span id="study-program-number" data-placeholder="P88"></span>
            </div>
            <div id="study-timer-controls">
                <button id="btn-plus-10m" class="control-btn">+10m</button><button id="btn-plus-1m"
                    class="control-btn">+1m</button><button id="btn-plus-1s" class="control-btn">+1s</button><button
                    id="btn-reset" class="control-btn">Reset</button><button id="btn-show-100s" class="control-btn">Show
                    1/100s</button><button id="btn-repeat-plus" class="control-btn">Repeat +1</button>
                <button id="btn-minus-10m" class="control-btn">-10m</button><button id="btn-minus-1m"
                    class="control-btn">-1m</button><button id="btn-minus-1s" class="control-btn">-1s</button>
                <button id="btn-prev-subject" class="control-btn">&lt;-</button><button id="btn-next-subject"
                    class="control-btn">-></button>
                <button id="btn-repeat-minus" class="control-btn">Repeat -1</button>
                <button id="btn-pset" class="control-btn">P-Set</button><button id="btn-start-pause"
                    class="control-btn">Start</button>
            </div>
        </div>
        <div id="records-container" class="timer-mode-container">
            <div id="records-header">
                <span id="records-title">Records</span>
                <div id="graph-wrapper">
                    <div id="graph-nav"></div>
                    <pre id="weekly-graph"></pre>
                    <div id="graph-x-axis"></div>
                </div>
            </div>
            <div id="log-summary-wrapper">
                <div id="log-list"></div>
                <pre id="subject-summary"></pre>
                <pre id="comparison-summary"></pre>
            </div>
        </div>
    </div>

    <script>
        /*******************************************************************
         * 1. グローバル設定・定数
         *******************************************************************/

        const DEBUG_SPEED_MULTIPLIER = 1;

        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
        let currentTimerMode = 'countdown';
        let previousTimerMode = 'countdown';
        const messageEl = document.getElementById('message-area');
        const switchBtn = document.getElementById('switch-timer-btn');
        const countdownContainer = document.getElementById('countdown-container');
        const studyTimerContainer = document.getElementById('study-timer-container');
        const minEl = document.getElementById('min'), secEl = document.getElementById('sec'), dayEl = document.getElementById('day'), hourEl = document.getElementById('hour'), msecEl = document.getElementById('msec'), yearEl = document.getElementById('year'), monthEl = document.getElementById('month'), dateEl = document.getElementById('date'), dayOfWeekEl = document.getElementById('day-of-week'), currentHourEl = document.getElementById('current-hour'), currentMinEl = document.getElementById('current-min'), currentSecEl = document.getElementById('current-sec'), currentMsecEl = document.getElementById('current-msec'), dayLabelEl = document.getElementById('day-label'), hourLabelEl = document.getElementById('hour-label'), currentHmsEl = document.getElementById('current-hms');
        const studyDisplayEl = document.getElementById('study-timer-display');
        const btnShow100s = document.getElementById('btn-show-100s');
        const btnStartPause = document.getElementById('btn-start-pause');
        const studyRepeatsTotalEl = document.getElementById('study-repeats-total');
        const studyRepeatsCompletedEl = document.getElementById('study-repeats-completed');
        const studyProgramNumberEl = document.getElementById('study-program-number');
        const switchRecordsBtn = document.getElementById('switch-records-btn');
        const recordsContainer = document.getElementById('records-container');
        const logListEl = document.getElementById('log-list');
        const subjectSummaryEl = document.getElementById('subject-summary');
        const comparisonSummaryEl = document.getElementById('comparison-summary')
        const recordsTitleEl = document.getElementById('records-title');
        const graphXAxisEl = document.getElementById('graph-x-axis');

        let filteredDayIndex = null;
        let weekOffset = 0;
        let currentRecordViewMode = 'weekly'; // 'weekly', 'monthly', 'total'

        /*******************************************************************
         * 2. 共通テストタイマー関連 (変更なし)
         *******************************************************************/

        const targetDate = new Date("2026-01-17T00:00:00");
        const holidays = ['2025-01-01', '2025-01-13', '2025-02-11', '2025-02-24', '2025-03-20', '2025-04-29', '2025-05-03', '2025-05-04', '2025-05-05', '2025-05-06', '2025-07-21', '2025-08-11', '2025-09-15', '2025-09-23', '2025-10-13', '2025-11-03', '2025-11-24'];
        const weekdays = ["SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT"];
        let currentDays = 0, remainingHolidays = 0;
        let lastCheckedDate = null, lastSecond = -1, highlightUntil = 0;

        function calculateRemainingHolidays(target) {
            let holidayCount = 0; const today = new Date(); today.setHours(0, 0, 0, 0);
            for (let d = today; d < target; d.setDate(d.getDate() + 1)) {
                const dayOfWeek = d.getDay();
                const dateString = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
                if (dayOfWeek === 0 || dayOfWeek === 6 || holidays.includes(dateString)) { holidayCount++; }
            }
            return holidayCount;
        }

        function updateCountdownTimer() {
            const now = new Date();
            if (now.getDate() !== lastCheckedDate) { remainingHolidays = calculateRemainingHolidays(targetDate); lastCheckedDate = now.getDate(); }
            const diff = targetDate.getTime() - now.getTime();
            if (diff > 0) {
                const days = Math.floor(diff / 864e5), hours = Math.floor(diff % 864e5 / 36e5), mins = Math.floor(diff % 36e5 / 6e4), secs = Math.floor(diff % 6e4 / 1e3), msecs = diff % 1e3;
                currentDays = days;
                minEl.textContent = String(mins).padStart(2, "0"); secEl.textContent = String(secs).padStart(2, "0"); dayEl.textContent = String(days);
                hourEl.textContent = String(hours).padStart(2, "0"); msecEl.textContent = String(msecs).padStart(3, "0");
                dayLabelEl.textContent = 1 === days ? "Day" : "Days"; hourLabelEl.textContent = 1 === hours ? "Hour" : "Hours";
            }
            const currentHour = now.getHours(), currentMin = now.getMinutes(), currentSec = now.getSeconds();
            yearEl.textContent = String(now.getFullYear()).padStart(4, "0"); monthEl.textContent = String(now.getMonth() + 1).padStart(2, "0"); dateEl.textContent = String(now.getDate()).padStart(2, "0");
            dayOfWeekEl.textContent = weekdays[now.getDay()]; currentHourEl.textContent = String(currentHour).padStart(2, "0"); currentMinEl.textContent = String(currentMin).padStart(2, "0");
            currentSecEl.textContent = String(currentSec).padStart(2, "0"); currentMsecEl.textContent = Math.floor(now.getMilliseconds() / 100);
            if (currentSec !== lastSecond) { if (currentMin === 59 && (currentSec >= 57)) { highlightUntil = now.getTime() + 100; } lastSecond = currentSec; }
            const isJihou = (currentMin === 0 && currentSec < 5), isHighlighted = now.getTime() < highlightUntil;
            isJihou || isHighlighted ? currentHmsEl.classList.add("jihou-highlight") : currentHmsEl.classList.remove("jihou-highlight");
        }

        /*******************************************************************
         * 3. ランダムメッセージ関連 (変更なし)
         *******************************************************************/

        const randomMessages = ["キョウツウテストマデ アト DDDニチ!", "シッテタ? キュウジツハアトddニチシカナインダヨ!", "ナニヤッテルンデスカ、 ベンキョウシテクダサイ!", "ガンバルアナタヲ オウエンシテイマス。", "ヒトヤスミモ ダイジデスヨ。", "モウコウコウモ オワッチャウネェ", "トキノナガレハ ハヤイモノダヨ", "ハナレバナレニ ナッテシマウノカナ...", "ベンキョウ ガンバレヨ!", "イママデノドリョクヲシンジテ。", "キミナラデキル!", "ラストスパートダ!", "サイコウノハルヲムカエヨウ!", "ムリシスギナイデネ。", "ヒトリジャナイヨ。", "アトスコシノシンボウ...", "コンディションヲトトノエテ。", "ケッカハカナラズツイテクル。", "オワッタラ パーットアソボウゼ!"];
        const TYPING_SPEED = 150, DELETING_SPEED = 100, GREETING_STAY_DURATION = 5000;

        async function messageCycle() {
            if (currentTimerMode !== 'countdown') return;
            const type = async text => { for (let i = 0; i < text.length; i++) { if (currentTimerMode !== 'countdown') { messageEl.textContent = ''; return false; } messageEl.textContent = text.substring(0, i + 1); await sleep(TYPING_SPEED); } return true; };
            const del = async () => { const currentText = messageEl.textContent; for (let i = currentText.length; i > 0; i--) { if (currentTimerMode !== 'countdown') { messageEl.textContent = ''; return false; } messageEl.textContent = currentText.substring(0, i - 1); await sleep(DELETING_SPEED); } return true; };
            const hour = new Date().getHours();
            let greeting = (hour >= 5 && hour < 10) ? "オハヨウゴザイマス" : (hour >= 10 && hour < 17) ? "コンニチハ" : "コンバンワ";
            if (!await type(greeting)) return;
            await sleep(GREETING_STAY_DURATION);
            if (!await del()) return;
            let rawMsg = randomMessages[Math.floor(Math.random() * randomMessages.length)];
            let processedMsg = rawMsg.replace('DDD', currentDays).replace('dd', remainingHolidays);
            if (!await type(processedMsg)) return;
            await sleep(5000 + Math.random() * 5000);
            if (!await del()) return;
        }

        async function runMessageLoop() {
            while (true) {
                if (currentTimerMode === 'countdown') { await messageCycle(); }
                await sleep(500);
            }
        }

        /*******************************************************************
         * 4. 時間割タイマー関連
         *******************************************************************/

        const subjects = ["Break", "Modern-Japanese", "Old-Japanese", "Old-Chinese", "Mathematics", "English", "Japan History", "World History", "Geography", "Physics", "Biology", "Science", "Information", "RANDOM"];
        let currentSubjectIndex = 0;
        let studyTimerState = 'setting', programs = [], settingTime = 0, runningTime = 0;
        let currentProgramIndex = 0, totalRepeats = 1, completedRepeats = 0;
        let showHundredths = false, timerInterval = null, isSettingProgram = false;
        let expectedEndTime = 0;
        const chimeSoundA = new Audio('Chime-a.wav');
        const chimeSoundB = new Audio('Chime-b.wav');
        let isAudioUnlocked = false;
        // ▼▼▼ Global for Stopwatch ▼▼▼
        let stopwatchStartTime = 0;
        let isStopwatchMode = false;
        // ▲▲▲ Global for Stopwatch ▲▲▲
        let chimeMode = 'A'; // 'A', 'B', 'OFF'
        let lastResetClickTime = 0; // For double-click detection

        let audioContext = null;

        function unlockAudio() {
            // Web Audio API Contextの初期化と再開 (iOS対策の強力なアンロック)
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }

            // 無音バッファの再生による強力なアンロック
            const buffer = audioContext.createBuffer(1, 1, 22050);
            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.connect(audioContext.destination);
            source.start(0);

            if (isAudioUnlocked) return;

            // Audio要素のアンロック: mutedではなくvolume=0で再生を試みる
            const originalVolA = chimeSoundA.volume;
            const originalVolB = chimeSoundB.volume;
            chimeSoundA.volume = 0;
            chimeSoundB.volume = 0;

            // iOSではload()を明示的に呼ぶと安定する
            chimeSoundA.load();
            chimeSoundB.load();

            Promise.all([chimeSoundA.play(), chimeSoundB.play()]).then(() => {
                chimeSoundA.pause(); chimeSoundB.pause();
                chimeSoundA.currentTime = 0; chimeSoundB.currentTime = 0;
                // 音量を戻す
                chimeSoundA.volume = originalVolA;
                chimeSoundB.volume = originalVolB;

                isAudioUnlocked = true;
                console.log("Audio unlocked successfully.");
            }).catch(error => {
                console.error("Audio unlock failed:", error);
                // 失敗時も音量は戻しておく
                chimeSoundA.volume = originalVolA;
                chimeSoundB.volume = originalVolB;
            });
        }

        function playChime() {
            if (chimeMode === 'OFF') return;
            if (!isAudioUnlocked) {
                console.warn("Audio is not unlocked yet. Cannot play chime.");
                return;
            }
            if (chimeMode === 'A') {
                chimeSoundA.pause(); chimeSoundA.currentTime = 0;
                chimeSoundA.play().catch(e => console.error("Chime A failed:", e));
            } else if (chimeMode === 'B') {
                chimeSoundB.pause(); chimeSoundB.currentTime = 0;
                chimeSoundB.play().catch(e => console.error("Chime B failed:", e));
            }
        }

        function updateStudyTimerDisplay() {
            // ▼▼▼ Stopwatch Logic ▼▼▼
            if (isStopwatchMode) {
                const diff = (studyTimerState === 'running') ? (Date.now() - stopwatchStartTime) : runningTime;

                // Main Display (MM:SS)
                const totalSeconds = Math.floor(diff / 1000);
                const totalMinutes = Math.floor(totalSeconds / 60);
                const hours = Math.floor(totalMinutes / 60);
                const minutes = totalMinutes % 60;
                const seconds = totalSeconds % 60;
                const days = Math.floor(hours / 24);
                const displayHours = hours % 24;
                const msec = diff % 1000;

                // MM:SS (Minutes 0-padded if Total Hours >= 1)
                const minutesStr = (hours > 0) ? String(minutes).padStart(2, '0') : String(minutes).padStart(2, '!');
                studyDisplayEl.textContent = `${minutesStr}:${String(seconds).padStart(2, '0')}`;

                // Lower Info: DDD HH mmm
                // DDD (Left)
                if (days > 0) {
                    studyRepeatsTotalEl.textContent = String(days).padStart(3, '!');
                } else {
                    studyRepeatsTotalEl.textContent = '!!!'; // Off/Hidden
                }

                // HH (Center)
                // "DDDが1以上の場合はHHは0埋め(そうでなければ消灯)" -> "If DDD>=1, HH 0-pad. Else Turn Off (DDD? or HH?)"
                // Interpretation: If DDD>=1, Show HH(00). If DDD=0, Show HH(!!) (Space padded/Visual) OR Hide?
                // Given "Stopwatch", seeing hours is important if >0. 
                // But if strict to "Otherwise Turn Off", and "It" is HH, then HH is hidden.
                // However, standard interpretation of user requirements "If X do Y (else Z)" usually applies to the formatting or visibility of the paired item.
                // Let's assume: If DDD>=1, HH is 0-padded. If DDD=0, HH is displayed normally (space padded if <10) IF >0, or hidden if 0?
                // "Wait, normal Timer mode puts '!!' if 0".
                // Let's show Hours if >0 OR if Days > 0.
                if (days > 0) {
                    studyRepeatsCompletedEl.textContent = String(displayHours).padStart(2, '0');
                } else {
                    // If no days, show hours if exists.
                    if (displayHours > 0) {
                        studyRepeatsCompletedEl.textContent = String(displayHours).padStart(2, '!');
                    } else {
                        studyRepeatsCompletedEl.textContent = '!!';
                    }
                }

                // mmm (Right)
                studyProgramNumberEl.textContent = String(msec).padStart(3, '0');

                return;
            }
            // ▲▲▲ Stopwatch Logic ▲▲▲

            let timeToShow = (studyTimerState === 'setting') ? settingTime * 1000 : runningTime;
            if (timeToShow < 0) timeToShow = 0;
            const totalSeconds = Math.floor(timeToShow / 1000), hours = Math.floor(totalSeconds / 3600), minutes = Math.floor((totalSeconds % 3600) / 60), seconds = totalSeconds % 60, hundredths = Math.floor((timeToShow % 1000) / 10);

            const minutesStr = (hours > 0) ? String(minutes).padStart(2, '0') : String(minutes).padStart(2, '!');
            studyDisplayEl.textContent = (showHundredths && totalSeconds < 60 && studyTimerState !== 'setting')
                ? `${String(seconds).padStart(2, '0')}.${String(hundredths).padStart(2, '0')}`
                : `${minutesStr}:${String(seconds).padStart(2, '0')}`;

            studyRepeatsCompletedEl.textContent = (hours > 0) ? String(hours).padStart(2, '!') : '!!';
            let displayRepeats;
            if (studyTimerState === 'setting') {
                displayRepeats = totalRepeats;
            } else {
                displayRepeats = (totalRepeats !== 0 && completedRepeats > totalRepeats) ? totalRepeats : completedRepeats;
            }
            studyRepeatsTotalEl.textContent = String(displayRepeats).padStart(3, '!');
            let programNumberToShow = (studyTimerState === 'setting') ? programs.length + 1 : currentProgramIndex + 1;
            const programNumberDigits = String(programNumberToShow).padStart(2, '0');
            studyProgramNumberEl.innerHTML = '';
            studyProgramNumberEl.textContent = `P${programNumberDigits}`;
        }

        function updateSubjectDisplay() {
            if (studyTimerState === 'setting' && !isSettingProgram) {
                const subject = subjects[currentSubjectIndex];
                if (programs.length > 0) {
                    // P02以降: 終了予定時刻を表示
                    // 終了時刻 = 現在時刻 + (これまでのプログラム合計時間 + 現在設定中の時間) * リピート回数
                    let totalProgramTime = 0;
                    programs.forEach(p => totalProgramTime += p.time);
                    totalProgramTime += settingTime;

                    const totalDuration = totalProgramTime * totalRepeats * 1000;
                    const projectedEndTime = Date.now() + (totalDuration / DEBUG_SPEED_MULTIPLIER);
                    const endStr = formatTime(projectedEndTime);

                    messageEl.style.height = 'auto';
                    messageEl.style.lineHeight = '1.2';
                    messageEl.innerHTML = `${subject}<br>(All ends at ${endStr})`;
                    messageEl.style.fontSize = '';
                } else {
                    // P01: 科目名のみ
                    messageEl.textContent = subject;
                    messageEl.style.height = '';     // Reset style
                    messageEl.style.lineHeight = ''; // Reset style
                }
            }
        }

        function updateRunningMessage() {
            if (!['running', 'paused', 'finished'].includes(studyTimerState) || programs.length === 0) return;

            // Allow multi-line
            messageEl.style.height = 'auto';
            messageEl.style.lineHeight = '1.2';

            const currentProgram = programs[currentProgramIndex];
            if (studyTimerState === 'paused') {
                messageEl.innerHTML = `${currentProgram.subject}<br>(Paused)`;
                messageEl.style.fontSize = '';
                return;
            }
            const endTimeFormatted = formatTime(expectedEndTime);
            if (currentProgram.subject === "Break") {
                const nextRep = (currentProgramIndex + 1 >= programs.length) ? (completedRepeats) : (completedRepeats - 1);
                if (totalRepeats !== 0 && nextRep >= totalRepeats) {
                    messageEl.innerHTML = 'Break<br>(Last one!)';
                } else {
                    const nextIndex = (currentProgramIndex + 1) % programs.length;
                    const nextSubject = programs[nextIndex].subject;
                    messageEl.innerHTML = `Break<br>(NEXT: ${nextSubject}, Starts at ${endTimeFormatted})`;
                }
                messageEl.style.fontSize = '29px';
            } else {
                messageEl.innerHTML = `${currentProgram.subject}<br>(Ends at ${endTimeFormatted})`;
                messageEl.style.fontSize = '';
            }
        }

        function timerTick() {
            if (isStopwatchMode) {
                updateStudyTimerDisplay();
                return;
            }
            runningTime = expectedEndTime - Date.now();
            if (runningTime <= 0) {
                const finishedProgram = programs[currentProgramIndex];
                if (finishedProgram.subject !== 'Break') {
                    const startTime = expectedEndTime - (finishedProgram.time * 1000 / DEBUG_SPEED_MULTIPLIER);
                    addRecord(startTime, expectedEndTime, finishedProgram.subject);
                }
                playChime();
                currentProgramIndex++;

                // ▼▼▼ Skip final Break if totalRepeats >= 2 ▼▼▼
                if (totalRepeats >= 2 && completedRepeats >= totalRepeats) {
                    if (currentProgramIndex < programs.length) {
                        const nextProg = programs[currentProgramIndex];
                        // If it is Break and is the last one in the program list
                        if (nextProg.subject === 'Break' && currentProgramIndex === programs.length - 1) {
                            currentProgramIndex++; // Skip it
                        }
                    }
                }
                // ▲▲▲ Skip final Break logic ▲▲▲
                if (currentProgramIndex >= programs.length) {
                    // ▼▼▼▼▼ ここからが修正箇所 ▼▼▼▼▼
                    // 完了チェックを先に行い、その後にカウンターを増やすように順番を変更
                    if (totalRepeats !== 0 && completedRepeats >= totalRepeats) {
                        studyTimerState = 'finished'; clearInterval(timerInterval); runningTime = 0;
                        messageEl.textContent = 'Your work is finished today!'; messageEl.style.fontSize = '';
                        btnStartPause.textContent = 'Finished'; updateStudyTimerDisplay(); return;
                    }
                    currentProgramIndex = 0;
                    completedRepeats++;
                    // ▲▲▲▲▲ ここまでが修正箇所 ▲▲▲▲▲
                }
                if (studyTimerState !== 'finished') {
                    runningTime = programs[currentProgramIndex].time * 1000;
                    expectedEndTime = Date.now() + (runningTime / DEBUG_SPEED_MULTIPLIER);
                    updateRunningMessage();
                }
            }
            updateStudyTimerDisplay();
        }

        function handleTimeChange(seconds) {
            if (studyTimerState !== 'setting' || isSettingProgram) return;
            settingTime += seconds;
            if (settingTime > 359999) settingTime = 359999;
            if (settingTime < 0) settingTime = 0;
            if (settingTime < 0) settingTime = 0;
            updateStudyTimerDisplay();
            updateSubjectDisplay(); // 時間変更時に終了予定時刻を更新
        }

        function handleRepeatChange(amount) {
            if (studyTimerState !== 'setting' || isSettingProgram) return;
            totalRepeats += amount;
            if (totalRepeats < 1) totalRepeats = 1;
            if (totalRepeats > 999) totalRepeats = 999;
            if (totalRepeats > 999) totalRepeats = 999;
            updateStudyTimerDisplay();
            updateSubjectDisplay(); // リピート変更時に終了予定時刻を更新
        }

        function resetStudyTimer() {
            clearInterval(timerInterval);
            studyTimerState = 'setting';
            programs = []; settingTime = 0; runningTime = 0;
            currentProgramIndex = 0; completedRepeats = 0;
            totalRepeats = 1;
            btnStartPause.textContent = 'Start';
            btnStartPause.classList.remove('toggled');
            messageEl.style.fontSize = '';
            messageEl.style.height = '';
            messageEl.style.lineHeight = '';
            currentSubjectIndex = 0;
            updateStudyTimerDisplay();
            updateSubjectDisplay();
            isStopwatchMode = false;
        }

        /*******************************************************************
         * 6. 記録機能関連
         *******************************************************************/

        const subjectAbbreviations = { "Modern-Japanese": "M-JPN. ", "Old-Japanese": "O-JPN. ", "Old-Chinese": "O-CHN. ", "Mathematics": "Math.  ", "English": "ENG.   ", "Japan History": "J-Hist.", "World History": "W-Hist.", "Geography": "Geo.   ", "Physics": "Phy.   ", "Biology": "Bio.   ", "Science": "Sci.   ", "Information": "Info.  ", };
        const formatTime = (timestamp) => { const d = new Date(timestamp); return `${String(d.getHours()).padStart(2, '0')}:${String(d.getMinutes()).padStart(2, '0')}`; };
        const formatDuration = (ms) => { if (ms <= 0) return '0h00m'; const totalMins = Math.round(ms / 60000); const hours = Math.floor(totalMins / 60); const mins = totalMins % 60; return `${hours}h${String(mins).padStart(2, '0')}m`; };
        const formatGraphDate = d => {
            const m = String(d.getMonth() + 1);
            const day = String(d.getDate());
            return `${m.padStart(2, ' ')}-${day.padStart(2, ' ')}`;
        };
        const loadRecords = () => JSON.parse(localStorage.getItem('studyRecords') || '[]');
        const saveRecords = (records) => localStorage.setItem('studyRecords', JSON.stringify(records));

        // ▼▼▼▼▼ Timer Persistence ▼▼▼▼▼
        function saveTimerState() {
            const state = {
                studyTimerState,
                runningTime,
                stopwatchStartTime,
                programs,
                settingTime,
                currentProgramIndex,
                completedRepeats,
                totalRepeats,
                isStopwatchMode,
                currentSubjectIndex,
                weekOffset,
                currentRecordViewMode,
                filteredDayIndex,
                chimeMode,
                timestamp: Date.now()
            };
            localStorage.setItem('studyTimerBackup', JSON.stringify(state));
        }

        function loadTimerState() {
            const backup = localStorage.getItem('studyTimerBackup');
            if (!backup) return;

            try {
                const state = JSON.parse(backup);
                // Valid state check: if it's "finished" or empty programs (and not setting), maybe treat as reset?
                // But let's trust the backup.

                programs = state.programs || [];
                settingTime = state.settingTime || 0;
                currentProgramIndex = state.currentProgramIndex || 0;
                completedRepeats = state.completedRepeats || 0;
                totalRepeats = state.totalRepeats || 1;
                isStopwatchMode = state.isStopwatchMode || false;
                currentSubjectIndex = state.currentSubjectIndex || 0;
                weekOffset = state.weekOffset || 0;
                currentRecordViewMode = state.currentRecordViewMode || 'weekly';
                weekOffset = state.weekOffset || 0;
                currentRecordViewMode = state.currentRecordViewMode || 'weekly';
                filteredDayIndex = state.filteredDayIndex === undefined ? null : state.filteredDayIndex;
                chimeMode = state.chimeMode || 'A';

                if (state.studyTimerState === 'running') {
                    const elapsed = Date.now() - state.timestamp;
                    if (isStopwatchMode) {
                        stopwatchStartTime = state.stopwatchStartTime;
                    } else {
                        runningTime = (state.runningTime || 0) - elapsed;
                        if (runningTime <= 0) runningTime = 0;
                        expectedEndTime = Date.now() + (runningTime / (typeof DEBUG_SPEED_MULTIPLIER !== 'undefined' ? DEBUG_SPEED_MULTIPLIER : 1));
                    }
                    timerInterval = setInterval(timerTick, 10);
                    studyTimerState = 'running';
                    btnStartPause.textContent = 'Pause';
                    btnStartPause.classList.add('toggled');
                } else if (state.studyTimerState === 'paused') {
                    studyTimerState = 'paused';
                    runningTime = state.runningTime || 0;
                    stopwatchStartTime = state.stopwatchStartTime || 0;
                    btnStartPause.textContent = 'Start'; // Or Resume
                    if (programs.length > 0) btnStartPause.textContent = 'Resume'; // Better UX
                } else if (state.studyTimerState === 'finished') {
                    studyTimerState = 'finished';
                    btnStartPause.textContent = 'Finished';
                } else {
                    studyTimerState = 'setting';
                }

                // Restore UI Mode
                if (studyTimerState !== 'setting' || programs.length > 0 || isStopwatchMode) {
                    currentTimerMode = 'study';
                    countdownContainer.style.display = 'none';
                    studyTimerContainer.style.display = 'block';
                    recordsContainer.style.display = 'none';
                    switchBtn.textContent = '共通テストタイマーへ';
                    messageEl.classList.add('subject-mode');
                }

                updateStudyTimerDisplay();
                updateSubjectDisplay();
                if (studyTimerState === 'running' || studyTimerState === 'paused') {
                    updateRunningMessage();
                }

            } catch (e) {
                console.error("Failed to load timer state", e);
            }
        }
        // ▲▲▲▲▲ Timer Persistence ▲▲▲▲▲

        function checkDailyReset() {
            const now = new Date();
            const lastResetStr = localStorage.getItem('lastReset');
            if (!lastResetStr) { localStorage.setItem('lastReset', now.getTime()); return; }
            const lastReset = new Date(parseInt(lastResetStr));
            let last4AM = new Date();
            last4AM.setHours(4, 0, 0, 0);
            if (now.getHours() < 4) { last4AM.setDate(last4AM.getDate() - 1); }
            if (lastReset < last4AM) {
                //saveRecords([]);
                localStorage.setItem('lastReset', now.getTime());
            }
        }

        function addRecord(startTime, endTime, subject) {
            const records = loadRecords();
            records.push({ id: startTime, startTime, endTime, subject });
            saveRecords(records);
            if (currentTimerMode === 'records') renderRecords();
        }

        function deleteRecord(id) {
            let records = loadRecords();
            records = records.filter(r => r.id !== id);
            saveRecords(records);
            renderRecords();
        }

        function handleDayClick(dayIndex) {
            if (filteredDayIndex === dayIndex) {
                filteredDayIndex = null;
            } else {
                filteredDayIndex = dayIndex;
            }
            renderRecords();
        }

        function renderWeeklyGraph() {
            const graphEl = document.getElementById('weekly-graph');
            const graphNavEl = document.getElementById('graph-nav');
            const records = loadRecords();

            const today = new Date();
            today.setDate(today.getDate() + (weekOffset * 7));

            const dayOfWeek = today.getDay();
            const diffToMonday = (dayOfWeek === 0) ? -6 : 1 - dayOfWeek;
            const monday = new Date(today);
            monday.setDate(today.getDate() + diffToMonday);
            monday.setHours(0, 0, 0, 0);
            const sunday = new Date(monday);
            sunday.setDate(monday.getDate() + 6);
            sunday.setHours(23, 59, 59, 999);

            // ▼▼▼▼▼ 変更箇所 (イベントリスナーの追加を削除) ▼▼▼▼▼
            graphNavEl.innerHTML = `
                <span class="nav-arrow" id="prev-week-btn">&lt;-</span>
                <span id="week-range-display">${formatGraphDate(monday)} - ${formatGraphDate(sunday)}</span>
                <span class="nav-arrow" id="next-week-btn">-&gt;</span>
            `;
            // ▲▲▲▲▲ 変更箇所 ▲▲▲▲▲

            const dailyTotals = Array(7).fill(0);
            for (const record of records) {
                const recordDate = new Date(record.startTime);
                if (recordDate >= monday && recordDate <= sunday) {
                    const recordDayIndex = (recordDate.getDay() + 6) % 7;
                    dailyTotals[recordDayIndex] += (record.endTime - record.startTime);
                }
            }

            const maxMs = Math.max(...dailyTotals, 1);
            const maxHours = maxMs / 3600000;
            let yAxisMaxHours = (maxHours > 0) ? Math.ceil(maxHours / 2) * 2 : 2;
            if (yAxisMaxHours > 100) yAxisMaxHours = 100;

            const GRAPH_HEIGHT = 16;
            const lines = [];
            const dayLabels = ['M', 'T', 'W', 'T', 'F', 'S', 'S'];

            for (let i = GRAPH_HEIGHT; i >= 0; i--) {
                let line = '';
                const currentLineHour = (i / GRAPH_HEIGHT) * yAxisMaxHours;

                if (i % 4 === 0) {
                    let labelText;
                    if (currentLineHour % 1 === 0) {
                        labelText = `${currentLineHour}h`;
                    } else {
                        labelText = `${currentLineHour}`;
                    }
                    line += labelText.padEnd(3, ' ') + '|';
                } else {
                    line += '   |';
                }

                if (i === 0) {
                    line += '-'.repeat(49);
                } else {
                    for (let dayIndex = 0; dayIndex < 7; dayIndex++) {
                        const dayHours = dailyTotals[dayIndex] / 3600000;
                        if (dayHours >= currentLineHour) {
                            line += '   -   ';
                        } else {
                            line += '       ';
                        }
                    }
                }
                lines.push(line);
            }
            graphEl.textContent = lines.join('\n');

            graphXAxisEl.innerHTML = '';
            const labelsContainer = document.createElement('div');
            labelsContainer.textContent = '    ';
            dayLabels.forEach((label, index) => {
                const labelSpan = document.createElement('span');
                labelSpan.textContent = label;
                labelSpan.className = 'day-label';
                if (index === filteredDayIndex) {
                    labelSpan.classList.add('active');
                }
                labelSpan.dataset.dayIndex = index;
                labelSpan.addEventListener('click', () => handleDayClick(index));
                labelsContainer.appendChild(labelSpan);
            });
            graphXAxisEl.appendChild(labelsContainer);
        }

        // ▼▼▼▼▼ この一行を追加 ▼▼▼▼▼
        const weekdayAbbrs = ["SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT"];

        function renderRecords() {
            const allRecords = loadRecords();
            logListEl.innerHTML = '';
            comparisonSummaryEl.innerHTML = ''; // 比較表示をクリア

            const today = new Date();
            today.setDate(today.getDate() + (weekOffset * 7));

            const dayOfWeek = today.getDay();
            const diffToMonday = (dayOfWeek === 0) ? -6 : 1 - dayOfWeek;
            const monday = new Date(today);
            monday.setDate(today.getDate() + diffToMonday);
            monday.setHours(0, 0, 0, 0);

            let summaryText = '-------------------------------------\nTotal (By Subjects)\n-------------------------------------\n';
            const subjectTotals = {};
            let grandTotal = 0;

            // --- 週表示の場合の処理 ---
            // --- 週表示の場合の処理 ---
            if (filteredDayIndex === null) {
                // ▼▼▼▼▼ ビューモード分岐 ▼▼▼▼▼
                if (currentRecordViewMode === 'monthly') {
                    renderMonthlyView(allRecords, monday, new Date(monday.getTime() + 6 * 24 * 60 * 60 * 1000));
                    return;
                } else if (currentRecordViewMode === 'total') {
                    renderTotalView(allRecords);
                    return;
                }
                // ▲▲▲▲▲ ビューモード分岐 ▲▲▲▲▲

                recordsTitleEl.textContent = (weekOffset === 0) ? 'This Week Records' : 'Records';
                const sunday = new Date(monday);
                sunday.setDate(monday.getDate() + 6);
                sunday.setHours(23, 59, 59, 999);

                // 表示週の記録を集計
                const thisWeekRecords = allRecords.filter(r => new Date(r.startTime) >= monday && new Date(r.startTime) <= sunday);
                for (const record of thisWeekRecords) {
                    const duration = record.endTime - record.startTime;
                    grandTotal += duration;
                    subjectTotals[record.subject] = (subjectTotals[record.subject] || 0) + duration;
                    const logItem = document.createElement('div');
                    logItem.className = 'log-item';
                    const dayStr = weekdays[new Date(record.startTime).getDay()];
                    logItem.innerHTML = `<span>${dayStr} ${formatTime(record.startTime)}-${formatTime(record.endTime)} ${record.subject} (${formatDuration(duration)})</span><button class="del-btn" data-id="${record.id}">[Del]</button>`;
                    logListEl.appendChild(logItem);
                }

                // 先週の記録を集計
                const lastWeekMonday = new Date(monday.getTime() - 7 * 24 * 60 * 60 * 1000);
                const lastWeekSunday = new Date(sunday.getTime() - 7 * 24 * 60 * 60 * 1000);
                let lastWeekTotal = 0;
                allRecords.forEach(r => {
                    const recordDate = new Date(r.startTime);
                    if (recordDate >= lastWeekMonday && recordDate <= lastWeekSunday) {
                        lastWeekTotal += (r.endTime - r.startTime);
                    }
                });

                // サマリーテキスト作成
                for (const subject in subjectAbbreviations) {
                    const totalMs = subjectTotals[subject] || 0;
                    if (totalMs > 0) summaryText += `${subjectAbbreviations[subject]}|${formatDuration(totalMs)}\n`;
                }
                summaryText += '-------------------------------------\n';
                summaryText += `Total  |${formatDuration(grandTotal)}\n`;
                const weeklyAverage = grandTotal / 7;
                summaryText += `W-Avg. |${formatDuration(weeklyAverage)}`;
                subjectSummaryEl.textContent = summaryText;

                // 先週との比較を作成
                const lastWeekAverage = lastWeekTotal / 7;
                const diff = weeklyAverage - lastWeekAverage;
                const prefix = diff > 1000 ? '+' : diff < -1000 ? '-' : '±';
                const color = prefix === '+' ? '#0d0' : prefix === '-' ? 'red' : 'orange';
                comparisonSummaryEl.textContent = `Vs.L-W ${prefix}${formatDuration(Math.abs(diff))}`;
                comparisonSummaryEl.style.color = color;

                // --- 日表示の場合の処理 ---
            } else {
                const targetDate = new Date(monday);
                targetDate.setDate(monday.getDate() + filteredDayIndex);
                const year = targetDate.getFullYear(), month = targetDate.getMonth(), date = targetDate.getDate();
                recordsTitleEl.textContent = `Records of ${month + 1}-${date}(${weekdays[(filteredDayIndex + 1) % 7]})`;

                // 表示日の記録を集計
                const dayRecords = allRecords.filter(r => {
                    const recordDate = new Date(r.startTime);
                    return recordDate.getFullYear() === year && recordDate.getMonth() === month && recordDate.getDate() === date;
                });

                for (const record of dayRecords) {
                    const duration = record.endTime - record.startTime;
                    grandTotal += duration;
                    subjectTotals[record.subject] = (subjectTotals[record.subject] || 0) + duration;
                    const logItem = document.createElement('div');
                    logItem.className = 'log-item';
                    logItem.innerHTML = `<span>${formatTime(record.startTime)}-${formatTime(record.endTime)} ${record.subject} (${formatDuration(duration)})</span><button class="del-btn" data-id="${record.id}">[Del]</button>`;
                    logListEl.appendChild(logItem);
                }

                // 昨日の記録を集計
                const yesterday = new Date(targetDate.getTime() - 24 * 60 * 60 * 1000);
                const yYear = yesterday.getFullYear(), yMonth = yesterday.getMonth(), yDate = yesterday.getDate();
                let yesterdayTotal = 0;
                allRecords.forEach(r => {
                    const recordDate = new Date(r.startTime);
                    if (recordDate.getFullYear() === yYear && recordDate.getMonth() === yMonth && recordDate.getDate() === yDate) {
                        yesterdayTotal += (r.endTime - r.startTime);
                    }
                });

                // サマリーテキスト作成
                for (const subject in subjectAbbreviations) {
                    const totalMs = subjectTotals[subject] || 0;
                    if (totalMs > 0) summaryText += `${subjectAbbreviations[subject]}|${formatDuration(totalMs)}\n`;
                }
                summaryText += '-------------------------------------\n';
                summaryText += `Total  |${formatDuration(grandTotal)}\n`;
                const subjectCount = Object.keys(subjectTotals).length;
                const dailyAverage = subjectCount > 0 ? grandTotal / subjectCount : 0;
                summaryText += `Avg.   |${formatDuration(dailyAverage)}`;
                subjectSummaryEl.textContent = summaryText;

                // 昨日との比較を作成
                const diff = grandTotal - yesterdayTotal;
                const prefix = diff > 1000 ? '+' : diff < -1000 ? '-' : '±';
                const color = prefix === '+' ? '#0d0' : prefix === '-' ? 'red' : 'orange';
                comparisonSummaryEl.textContent = `Vs.YTD ${prefix}${formatDuration(Math.abs(diff))}`;
                comparisonSummaryEl.style.color = color;
            }

            // グラフは最後に描画
            if (currentRecordViewMode === 'weekly') renderWeeklyGraph();
        }

        // ▼▼▼▼▼ 4週間表示の実装 ▼▼▼▼▼
        const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        const getOrdinal = (n) => {
            const s = ["th", "st", "nd", "rd"];
            const v = n % 100;
            return n + (s[(v - 20) % 10] || s[v] || s[0]);
        };

        function renderMonthlyView(allRecords, monday, sunday) {
            recordsTitleEl.textContent = '4-Week Summary';

            // 4週間のデータを準備 (新しい順: 今週 -> 3週間前)
            const weeklyData = [];
            for (let i = 0; i < 4; i++) {
                const wStart = new Date(monday);
                wStart.setDate(monday.getDate() - (i * 7));
                const wEnd = new Date(wStart);
                wEnd.setDate(wStart.getDate() + 6);
                wEnd.setHours(23, 59, 59, 999);

                let wTotal = 0;
                allRecords.forEach(r => {
                    const rd = new Date(r.startTime);
                    if (rd >= wStart && rd <= wEnd) {
                        wTotal += (r.endTime - r.startTime);
                    }
                });
                weeklyData.push({ start: wStart, end: wEnd, total: wTotal });
            }
            // 表示順は古い順 (3週間前 -> 今週) に直す
            weeklyData.reverse();

            // リスト表示
            let summaryText = 'Total (By week)\n';
            weeklyData.forEach(d => {
                const startStr = `${monthNames[d.start.getMonth()]} ${getOrdinal(d.start.getDate())}`;
                const endStr = `${getOrdinal(d.end.getDate())}`;
                // パディング調整 (簡易的)
                const dateRange = `${startStr} - ${endStr}`;
                const paddedDateRange = dateRange.padEnd(17, ' ');
                summaryText += `${paddedDateRange}|${formatDuration(d.total)}\n`;
            });

            const grandTotal = weeklyData.reduce((sum, d) => sum + d.total, 0);
            summaryText += '----------------------------\n';
            summaryText += `${'4 Weeks Total'.padEnd(17, ' ')}|${formatDuration(grandTotal)}\n`;
            const avg = grandTotal / 4;
            summaryText += `${'4 Weeks Average'.padEnd(17, ' ')}|${formatDuration(avg)}`;
            subjectSummaryEl.textContent = summaryText;

            // 比較 (Vs.L-W): 1週間ずらした4週間 (つまり、一番古い週のさらに1週間前から、今週の1週間前まで)
            // Current: [W-3, W-2, W-1, W0]
            // Prev:    [W-4, W-3, W-2, W-1]
            // Diff = CurrentSum - PrevSum
            // PrevSum = (Sum of W-3..W-1) + (Sum of W-4)
            // CurrentSum = (Sum of W-3..W-1) + (Sum of W0)
            // Diff = Sum(W0) - Sum(W-4)
            // ...という計算もできるが、単純に再計算する

            const prevWindowEnd = new Date(monday);
            prevWindowEnd.setDate(monday.getDate() - 7); // 先週の月曜が基準...ではなく、先週の日曜が終わり
            // mondayは今週の月曜。
            // 今週の4週間: [Monday-3weeks, Sunday]
            // 先週の4週間: [Monday-4weeks, Sunday-1week]

            // 単純に total を計算
            let prevGrandTotal = 0;
            for (let i = 0; i < 4; i++) {
                // 1週間ずらすので i+1
                const wStart = new Date(monday);
                wStart.setDate(monday.getDate() - ((i + 1) * 7));
                const wEnd = new Date(wStart);
                wEnd.setDate(wStart.getDate() + 6);
                wEnd.setHours(23, 59, 59, 999);

                allRecords.forEach(r => {
                    const rd = new Date(r.startTime);
                    if (rd >= wStart && rd <= wEnd) {
                        prevGrandTotal += (r.endTime - r.startTime);
                    }
                });
            }

            const prevAvg = prevGrandTotal / 4;
            const diff = avg - prevAvg;
            const prefix = diff > 1000 ? '+' : diff < -1000 ? '-' : '±';
            const color = prefix === '+' ? '#0d0' : prefix === '-' ? 'red' : 'orange';
            comparisonSummaryEl.textContent = `${'Vs. Last 4 Weeks'.padEnd(17, ' ')}${prefix}${formatDuration(Math.abs(diff))}`;
            comparisonSummaryEl.style.color = color;

            // グラフ描画
            const graphEl = document.getElementById('weekly-graph');
            const graphNavEl = document.getElementById('graph-nav');

            // ナビゲーション更新
            // 4週間の範囲を表示: 一番古い週の月曜 - 今週の日曜
            const rangeStart = weeklyData[0].start;
            const rangeEnd = weeklyData[3].end;

            graphNavEl.innerHTML = `
                <span class="nav-arrow" id="prev-week-btn">&lt;-</span>
                <span id="week-range-display">${formatGraphDate(rangeStart)} - ${formatGraphDate(rangeEnd)}</span>
                <span class="nav-arrow" id="next-week-btn">-&gt;</span>
            `;

            const maxMs = Math.max(...weeklyData.map(d => d.total), 1);
            const maxHours = maxMs / 3600000;
            let yAxisMaxHours = (maxHours > 0) ? Math.ceil(maxHours / 2) * 2 : 2;
            if (yAxisMaxHours > 100) yAxisMaxHours = 100;

            const GRAPH_HEIGHT = 16;
            const lines = [];

            for (let i = GRAPH_HEIGHT; i >= 0; i--) {
                let line = '';
                const currentLineHour = (i / GRAPH_HEIGHT) * yAxisMaxHours;

                if (i % 4 === 0) {
                    let labelText = (currentLineHour % 1 === 0) ? `${currentLineHour}h` : `${currentLineHour}`;
                    // "10.5" のように4文字になる場合は "|" を省略してズレを防ぐ
                    if (labelText.length > 3) {
                        line += labelText;
                    } else {
                        line += labelText.padEnd(3, ' ') + '|';
                    }
                } else {
                    line += '   |';
                }

                if (i === 0) {
                    line += '-'.repeat(57); // 4 + 13*4 + 1 (separator) = 57 (approx)
                } else {
                    // 4本のバーを描画
                    // 幅を広めに取る (13文字幅)
                    for (let wIndex = 0; wIndex < 4; wIndex++) {
                        const wHours = weeklyData[wIndex].total / 3600000;
                        if (wHours >= currentLineHour) {
                            line += '    -----    '; // 4 + 5 + 4 = 13
                        } else {
                            line += '             '; // 13
                        }
                    }
                }
                lines.push(line);
            }
            graphEl.textContent = lines.join('\n');

            // X軸ラベル
            graphXAxisEl.innerHTML = '';
            const labelsContainer = document.createElement('div');
            labelsContainer.textContent = '    '; // Y軸ラベル分のスペース
            // 4つのラベル
            weeklyData.forEach(d => {
                const labelSpan = document.createElement('span');
                // "Nov 17-23" 形式
                const mStr = monthNames[d.start.getMonth()];
                const dStart = d.start.getDate();
                const dEnd = d.end.getDate();
                // 月またぎの場合: Nov 24-30, Dec 1-7
                // スペースが限られているので短縮形を検討
                // "Nov 17-23" (9文字) -> 13文字分のスペースがある
                let labelText = `${mStr} ${dStart}-${dEnd}`;
                if (d.start.getMonth() !== d.end.getMonth()) {
                    labelText = `${mStr} ${dStart}-${monthNames[d.end.getMonth()]} ${dEnd}`;
                }

                labelSpan.textContent = labelText;
                labelSpan.style.display = 'inline-block';
                labelSpan.style.width = '13ch'; // グラフのバー幅に合わせる
                labelSpan.style.textAlign = 'center';
                // labelSpan.style.fontSize = '10px'; // フォントサイズを戻す
                labelsContainer.appendChild(labelSpan);
            });
            graphXAxisEl.appendChild(labelsContainer);
        }
        // ▲▲▲▲▲ 4週間表示の実装 ▲▲▲▲▲

        // ▼▼▼▼▼ Total Records表示の実装 ▼▼▼▼▼
        function renderTotalView(allRecords) {
            recordsTitleEl.textContent = 'Total Records';
            comparisonSummaryEl.innerHTML = ''; // 比較はなし（または必要に応じて実装）

            // 集計
            const subjectTotals = {};
            let grandTotal = 0;
            allRecords.forEach(r => {
                const duration = r.endTime - r.startTime;
                grandTotal += duration;
                subjectTotals[r.subject] = (subjectTotals[r.subject] || 0) + duration;
            });

            // 0hの教科を除外してソート（降順）
            const sortedSubjects = Object.keys(subjectTotals)
                .filter(s => subjectTotals[s] > 0)
                .sort((a, b) => subjectTotals[b] - subjectTotals[a]);

            // リスト表示
            let summaryText = 'Total (By Subjects)\n--------------------------------\n';
            sortedSubjects.forEach(subject => {
                const totalMs = subjectTotals[subject];
                const name = subjectAbbreviations[subject] || subject;
                summaryText += `${name.padEnd(8, ' ')}|${formatDuration(totalMs)}\n`;
            });
            summaryText += '--------------------------------\n';
            summaryText += `Total   |${formatDuration(grandTotal)}\n`;
            const avg = sortedSubjects.length > 0 ? grandTotal / sortedSubjects.length : 0;
            summaryText += `Avg.    |${formatDuration(avg)}`; // Total / (教科数)

            subjectSummaryEl.textContent = summaryText;
            logListEl.innerHTML = ''; // ログリストは非表示（または必要なら表示）

            // グラフ描画
            const graphEl = document.getElementById('weekly-graph');
            const graphNavEl = document.getElementById('graph-nav');
            const graphXAxisEl = document.getElementById('graph-x-axis');

            // ナビゲーション非表示（全期間なので）
            graphNavEl.innerHTML = '';

            if (sortedSubjects.length === 0) {
                graphEl.textContent = 'No Data';
                graphXAxisEl.innerHTML = '';
                return;
            }

            const maxMs = Math.max(...sortedSubjects.map(s => subjectTotals[s]), 1);
            const maxHours = maxMs / 3600000;
            let yAxisMaxHours = (maxHours > 0) ? Math.ceil(maxHours / 2) * 2 : 2;
            if (yAxisMaxHours > 1000) yAxisMaxHours = Math.ceil(maxHours / 100) * 100; // 大きすぎる場合の調整

            const GRAPH_HEIGHT = 16;
            const lines = [];

            for (let i = GRAPH_HEIGHT; i >= 0; i--) {
                let line = '';
                const currentLineHour = (i / GRAPH_HEIGHT) * yAxisMaxHours;

                if (i % 4 === 0) {
                    let labelText = (currentLineHour % 1 === 0) ? `${currentLineHour}h` : `${currentLineHour.toFixed(1)}`;
                    if (labelText.length > 4) {
                        line += labelText.substring(0, 4); // スペースの都合上切り詰め
                    } else {
                        line += labelText.padEnd(4, ' ') + '|';
                    }
                } else {
                    line += '    |';
                }

                if (i === 0) {
                    line += '-'.repeat(sortedSubjects.length * 6 + 2);
                } else {
                    for (const subject of sortedSubjects) {
                        const sHours = subjectTotals[subject] / 3600000;
                        if (sHours >= currentLineHour) {
                            line += '  --  ';
                        } else {
                            line += '      ';
                        }
                    }
                }
                lines.push(line);
            }
            graphEl.textContent = lines.join('\n');

            // X軸ラベル
            graphXAxisEl.innerHTML = '';
            const labelsContainer = document.createElement('div');
            labelsContainer.textContent = '     '; // Y軸ラベル分
            sortedSubjects.forEach(subject => {
                const labelSpan = document.createElement('span');
                // 短縮名を使用、さらに短くする
                let abbr = subjectAbbreviations[subject] ? subjectAbbreviations[subject].trim() : subject.substring(0, 3);
                // "M-JPN." -> "M-JP" 程度に
                abbr = abbr.replace(/\./g, '').substring(0, 4);

                labelSpan.textContent = abbr;
                labelSpan.style.display = 'inline-block';
                labelSpan.style.width = '6ch';
                labelSpan.style.textAlign = 'center';
                labelSpan.style.fontSize = '10px';
                labelsContainer.appendChild(labelSpan);
            });
            graphXAxisEl.appendChild(labelsContainer);
        }
        // ▲▲▲▲▲ Total Records表示の実装 ▲▲▲▲▲

        /*******************************************************************
         * 7. メイン制御・初期化
         *******************************************************************/

        function makeButtonAccelerate(element, action) {
            let timeoutId, intervalId;
            const startAction = (e) => {
                e.preventDefault(); unlockAudio(); action();
                timeoutId = setTimeout(() => { intervalId = setInterval(action, 100); }, 500);
            };
            const stopAction = () => { clearTimeout(timeoutId); clearInterval(intervalId); };
            element.addEventListener('mousedown', startAction);
            element.addEventListener('mouseup', stopAction);
            element.addEventListener('mouseleave', stopAction);
            element.addEventListener('touchstart', startAction);
            element.addEventListener('touchend', stopAction);
        }

        // ▼▼▼▼▼ 追加箇所 (グラフナビゲーションの連続操作機能) ▼▼▼▼▼
        function setupGraphNavControls() {
            const graphNavEl = document.getElementById('graph-nav');
            let navTimeoutId, navIntervalId;

            // ボタンを離した時、または操作がキャンセルされた時に実行する処理
            const stopNavAction = () => {
                clearTimeout(navTimeoutId);
                clearInterval(navIntervalId);
                // windowに追加したイベントリスナーを必ず削除する
                window.removeEventListener('mouseup', stopNavAction);
                window.removeEventListener('touchend', stopNavAction);
                window.removeEventListener('touchcancel', stopNavAction); // ▼▼▼ 変更箇所 ▼▼▼
            };

            // ボタンを押し始めた時に実行する処理
            const startNavAction = (e) => {
                // 日付範囲をクリックした場合は、現在週に戻るだけ
                if (e.target.id === 'week-range-display') {
                    weekOffset = 0;
                    renderRecords();
                    return;
                }
                // 矢印（<- or ->）以外で発動しないようにする
                if (!e.target.classList.contains('nav-arrow')) {
                    return;
                }

                e.preventDefault();

                const direction = (e.target.id === 'prev-week-btn') ? -1 : 1;

                const handleNav = (dir) => {
                    weekOffset += dir;
                    renderRecords();
                };

                // 1. まず1回だけ動かす
                handleNav(direction);

                // 2. 押し続けた場合の連続動作を設定 (マウスのみ)
                if (e.type === 'mousedown') {
                    navTimeoutId = setTimeout(() => {
                        navIntervalId = setInterval(() => handleNav(direction), 100);
                    }, 500);
                }

                // 3. ボタンを離したことなどを検知するため、windowにリスナーを追加
                window.addEventListener('mouseup', stopNavAction);
                window.addEventListener('touchend', stopNavAction);
                window.addEventListener('touchcancel', stopNavAction); // ▼▼▼ 変更箇所 ▼▼▼
            };

            // イベントリスナーを設定
            graphNavEl.addEventListener('mousedown', startNavAction);
            graphNavEl.addEventListener('touchstart', startNavAction, { passive: false });
        }
        // ▲▲▲▲▲ 追加箇所 ▲▲▲▲▲

        function setupEventListeners() {
            switchBtn.addEventListener('click', () => {
                unlockAudio();
                if (currentTimerMode === 'records') {
                    currentTimerMode = previousTimerMode;
                } else {
                    currentTimerMode = currentTimerMode === 'countdown' ? 'study' : 'countdown';
                    if (currentTimerMode === 'study') resetStudyTimer();
                }

                countdownContainer.style.display = currentTimerMode === 'countdown' ? 'block' : 'none';
                studyTimerContainer.style.display = currentTimerMode === 'study' ? 'block' : 'none';
                recordsContainer.style.display = 'none';

                if (currentTimerMode === 'countdown') {
                    switchBtn.textContent = '時間割タイマーへ';
                    messageEl.classList.remove('subject-mode');
                } else {
                    switchBtn.textContent = '共通テストタイマーへ';
                    messageEl.classList.add('subject-mode');
                }
                messageEl.style.fontSize = '';
            });

            switchRecordsBtn.addEventListener('click', () => {
                unlockAudio();
                if (currentTimerMode !== 'records') {
                    previousTimerMode = currentTimerMode;
                }
                currentTimerMode = 'records';
                countdownContainer.style.display = 'none';
                studyTimerContainer.style.display = 'none';
                recordsContainer.style.display = 'block';
                switchBtn.textContent = '戻る';
                filteredDayIndex = null;
                weekOffset = 0;
                currentRecordViewMode = 'weekly'; // Reset to weekly
                renderRecords();
            });

            recordsTitleEl.addEventListener('click', () => {
                unlockAudio();
                if (currentRecordViewMode === 'weekly') {
                    currentRecordViewMode = 'monthly';
                } else if (currentRecordViewMode === 'monthly') {
                    currentRecordViewMode = 'total';
                } else {
                    currentRecordViewMode = 'weekly';
                }
                renderRecords();
            });

            logListEl.addEventListener('click', (e) => {
                if (e.target.classList.contains('del-btn')) {
                    const recordId = parseInt(e.target.dataset.id);
                    deleteRecord(recordId);
                }
            });

            makeButtonAccelerate(document.getElementById('btn-plus-10m'), () => handleTimeChange(600));
            makeButtonAccelerate(document.getElementById('btn-plus-1m'), () => handleTimeChange(60));
            makeButtonAccelerate(document.getElementById('btn-plus-1s'), () => handleTimeChange(1));
            makeButtonAccelerate(document.getElementById('btn-minus-10m'), () => handleTimeChange(-600));
            makeButtonAccelerate(document.getElementById('btn-minus-1m'), () => handleTimeChange(-60));
            makeButtonAccelerate(document.getElementById('btn-minus-1s'), () => handleTimeChange(-1));
            makeButtonAccelerate(document.getElementById('btn-repeat-plus'), () => handleRepeatChange(1));
            makeButtonAccelerate(document.getElementById('btn-repeat-minus'), () => handleRepeatChange(-1));

            // ▼▼▼▼▼ 変更箇所 (教科送りボタンのイベントリスナー) ▼▼▼▼▼
            const nextSubjectAction = () => {
                if (studyTimerState !== 'setting' || isSettingProgram) return;
                currentSubjectIndex = (currentSubjectIndex + 1) % subjects.length;
                updateSubjectDisplay();
            };
            const prevSubjectAction = () => {
                if (studyTimerState !== 'setting' || isSettingProgram) return;
                currentSubjectIndex = (currentSubjectIndex - 1 + subjects.length) % subjects.length;
                updateSubjectDisplay();
            };
            makeButtonAccelerate(document.getElementById('btn-next-subject'), nextSubjectAction);
            makeButtonAccelerate(document.getElementById('btn-prev-subject'), prevSubjectAction);
            // ▲▲▲▲▲ 変更箇所 ▲▲▲▲▲

            // Modified Reset Handler for Chime Toggle
            document.getElementById('btn-reset').addEventListener('click', () => {
                const now = Date.now();
                // Condition: No programs set, Subject is Break
                // Check BEFORE resetStudyTimer because reset clears subject index
                if (programs.length === 0 && studyTimerState === 'setting' && subjects[currentSubjectIndex] === 'Break') {
                    if (now - lastResetClickTime < 500) {
                        // Double Click Detected
                        if (chimeMode === 'A') chimeMode = 'B';
                        else if (chimeMode === 'B') chimeMode = 'OFF';
                        else chimeMode = 'A';

                        messageEl.style.height = 'auto'; // Ensure visibility
                        let modeStr = (chimeMode === 'OFF') ? "Off" : chimeMode;
                        messageEl.textContent = `Chime: ${modeStr}`;
                        // Prevent "Reset" form clearing this message immediately? 
                        // resetStudyTimer clears messageEl style usually but maybe not text immediately if we set it after?
                        // Actually resetStudyTimer sets messageEl.style.fontSize = '' etc. and updateSubjectDisplay sets text.

                        // We need to call resetStudyTimer first or after?
                        // If we call resetStudyTimer(), it resets text to Subject Name.
                        // So we should toggle flag, call reset, then OVERWRITE message.

                        // Wait, if it's a double click, the FIRST click already called resetStudyTimer (and reset subject to 0/Break -> Modern-Japanese probably?)

                        // Ah, resetStudyTimer sets currentSubjectIndex = 0.
                        // So after 1st click, subject becomes subjects[0] (Break? No, 0 is Break in the list? Let's check).

                        // subjects = ["Break", "Modern-Japanese", ...]
                        // So Reset sets it to "Break" (Index 0).

                        // So 1st click:
                        //   State: Setting, Prog: [], Subject: Break (if user set it to Break)
                        //   Action: Reset -> Subject Index = 0 (Break). 

                        // 2nd click:
                        //   State: Setting, Prog: [], Subject: Break (Index 0)
                        //   Action: Double click detected -> Toggle.
                        resetStudyTimer();
                        messageEl.textContent = `Chime: ${modeStr}`;
                        // Keep message for 3 seconds
                        // We need to block updateSubjectDisplay from overwriting it? 
                        // updateSubjectDisplay checks "if studyTimerState === setting && !isSettingProgram".

                        // We can force it.
                        setTimeout(() => {
                            updateSubjectDisplay(); // Revert to subject name after 3s
                        }, 3000);

                        lastResetClickTime = 0; // Reset double click timer
                        return;
                    }
                }
                lastResetClickTime = now;
                resetStudyTimer();
            });
            btnShow100s.addEventListener('click', () => {
                showHundredths = !showHundredths; btnShow100s.classList.toggle('toggled', showHundredths); updateStudyTimerDisplay();
            });

            document.getElementById('btn-pset').addEventListener('click', async () => {
                if (studyTimerState !== 'setting' || settingTime === 0 || programs.length >= 99 || isSettingProgram) return;
                unlockAudio(); isSettingProgram = true;
                let subjectToSet = subjects[currentSubjectIndex];
                if (subjectToSet === 'RANDOM') {
                    const candidateSubjects = subjects.filter(s => s !== 'Break' && s !== 'RANDOM');
                    subjectToSet = candidateSubjects[Math.floor(Math.random() * candidateSubjects.length)];
                }
                programs.push({ time: settingTime, subject: subjectToSet });
                const programNumberStr = String(programs.length).padStart(2, '0');
                messageEl.textContent = `P${programNumberStr} is set to ${subjectToSet}`;
                settingTime = 0;
                updateStudyTimerDisplay();
                await sleep(2000);
                currentSubjectIndex = 0; isSettingProgram = false; updateSubjectDisplay();
            });

            btnStartPause.addEventListener('click', () => {
                if (isSettingProgram || studyTimerState === 'finished') return;
                unlockAudio();

                // ▼▼▼ START of Change for Stopwatch ▼▼▼
                if (studyTimerState === 'setting') {
                    const subject = subjects[currentSubjectIndex];
                    if (programs.length === 0 && settingTime === 0 && subject !== 'Break') {
                        // Enter Stopwatch Mode
                        isStopwatchMode = true;
                        studyTimerState = 'running';
                        stopwatchStartTime = Date.now();

                        btnStartPause.textContent = 'Finish';
                        btnStartPause.classList.add('toggled');

                        // LED Cal Display: (Subject name) (Starts from hh:mm)
                        const now = new Date();
                        const startStr = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
                        messageEl.style.height = 'auto'; // Allow multi-line
                        messageEl.style.lineHeight = '1.2';
                        messageEl.innerHTML = `${subject}<br>(Starts from ${startStr})`;
                        messageEl.classList.add('subject-mode'); // Ensure font matches

                        timerInterval = setInterval(timerTick, 10);
                        updateStudyTimerDisplay();
                        return;
                    }
                }

                if (isStopwatchMode && studyTimerState === 'running') {
                    // Finish Pressed
                    const endTime = Date.now();
                    const startTime = stopwatchStartTime;
                    runningTime = endTime - startTime; // Save final duration
                    studyTimerState = 'finished';
                    clearInterval(timerInterval);
                    btnStartPause.textContent = 'Finished';

                    // LED Cal: Recorded: (Subject name) \n ([start time] - [end time])
                    const sDate = new Date(startTime);
                    const eDate = new Date(endTime);
                    const sStr = `${String(sDate.getHours()).padStart(2, '0')}:${String(sDate.getMinutes()).padStart(2, '0')}`;
                    const eStr = `${String(eDate.getHours()).padStart(2, '0')}:${String(eDate.getMinutes()).padStart(2, '0')}`;

                    // Note: message-area is single line usually, but we can try generic LED text.
                    // User requested:
                    // Recorded: (Subject name)
                    // ([start time] - [end time])
                    // This might require <br> or 2 lines. messageEl uses textContent.
                    // Let's use generic text with spaces or a separating char if one line.
                    // Or change innerHTML.
                    const subject = subjects[currentSubjectIndex];
                    messageEl.style.height = 'auto'; // Allow multi-line
                    messageEl.style.lineHeight = '1.2';
                    messageEl.innerHTML = `Recorded: ${subject}<br>(${sStr} - ${eStr})`;

                    addRecord(startTime, endTime, subject);

                    setTimeout(() => {
                        messageEl.textContent = "Your work is finished today!";
                    }, 3000);

                    updateStudyTimerDisplay();
                    return;
                }
                // ▲▲▲ END of Change for Stopwatch ▲▲▲

                if (studyTimerState === 'setting') {
                    if (programs.length === 0 && settingTime > 0) {
                        let subjectToSet = subjects[currentSubjectIndex];
                        if (subjectToSet === 'RANDOM') {
                            const candidateSubjects = subjects.filter(s => s !== 'Break' && s !== 'RANDOM');
                            subjectToSet = candidateSubjects[Math.floor(Math.random() * candidateSubjects.length)];
                        }
                        programs.push({ time: settingTime, subject: subjectToSet });
                        settingTime = 0;
                    }
                    if (programs.length === 0) return;
                    studyTimerState = 'running';
                    currentProgramIndex = 0; completedRepeats = 0; updateStudyTimerDisplay(); completedRepeats = 1;
                    runningTime = programs[0].time * 1000;
                    expectedEndTime = Date.now() + (runningTime / DEBUG_SPEED_MULTIPLIER);
                    updateRunningMessage();
                    timerInterval = setInterval(timerTick, 10);
                    btnStartPause.textContent = 'Pause'; btnStartPause.classList.add('toggled');
                } else if (studyTimerState === 'running') {
                    studyTimerState = 'paused'; clearInterval(timerInterval);
                    runningTime = expectedEndTime - Date.now();
                    btnStartPause.textContent = 'Resume';
                    updateRunningMessage();
                } else if (studyTimerState === 'paused') {
                    studyTimerState = 'running';
                    expectedEndTime = Date.now() + runningTime;
                    updateRunningMessage();
                    timerInterval = setInterval(timerTick, 10);
                    btnStartPause.textContent = 'Pause';
                }
            });
        }

        function initialize() {
            checkDailyReset();
            countdownContainer.style.display = 'block';
            setInterval(updateCountdownTimer, 1);
            runMessageLoop();
            resetStudyTimer();
            setupEventListeners();
            // ▼▼▼▼▼ 追加箇所 ▼▼▼▼▼
            setupGraphNavControls(); // グラフナビゲーションのイベントリスナーを一度だけ設定
            // ▲▲▲▲▲ 追加箇所 ▲▲▲▲▲

            loadTimerState();
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'hidden') saveTimerState();
            });
            window.addEventListener('beforeunload', saveTimerState);
            window.addEventListener('pagehide', saveTimerState);
        }

        initialize();

    </script>
</body>

</html>